C51 COMPILER V9.56.0.0   SEG                                                               01/25/2025 07:47:21 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE SEG
OBJECT MODULE PLACED IN .\Objects\seg.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\Driver\seg.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTE
                    -XTEND PRINT(.\Listings\seg.lst) TABS(2) OBJECT(.\Objects\seg.obj)

line level    source

   1          sfr  P0 = 0x80;
   2          sfr  P2 = 0xA0;
   3          // P0输出: ucData――数据，ucAddr――地址（4~7）
   4          void P0_Out(unsigned char ucData, unsigned char ucAddr)
   5          {
   6   1        P0 = ucData;                        // P0输出数据
   7   1        P2 |= ucAddr << 5;                  // 置位P27~P25
   8   1        P2 &= 0x1f;                         // 复位P27~P25
   9   1      }
  10          // LED显示: ucLed――LED值
  11          void Led_Disp(unsigned char ucLed)
  12          {
  13   1        P0_Out(~ucLed, 4);
  14   1      }
  15          // ULN控制：ucUln=0：关闭继电器，ucUln=0x10：打开继电器
  16          void Uln_Ctrl(unsigned char ucUln)
  17          {
  18   1        P0_Out(ucUln, 5);
  19   1      }
  20          // 关闭外设
  21          void Close_Peripheral(void)
  22          {
  23   1        P2 &= 0x1f;                         // 复位P27~P25
  24   1        Led_Disp(0);                        // 熄灭LED
  25   1        Uln_Ctrl(0);                        // 关闭继电器和蜂鸣器
  26   1      }
  27          // 显示代码转换：pucSeg_Char―显示字符，pucSeg_Code―显示代码
  28          void Seg_Tran(unsigned char *pucSeg_Buf, unsigned char *pucSeg_Code)
  29          {
  30   1        unsigned char i, j=0, temp;
  31   1        for (i=0; i<8; i++, j++)
  32   1        {
  33   2          switch (pucSeg_Buf[j]) 
  34   2          { // 低电平点亮段，段码[MSB...LSB]对应码顺序为[dp g f e d c b a]
  35   3            case '0': temp = 0xc0; break;         // 1 1 0 0 0 0 0 0
  36   3            case '1': temp = 0xf9; break;         // 1 1 1 1 1 0 0 1
  37   3      //    case '1': temp = 0xcf; break;         // 1 1 0 0 1 1 1 1
  38   3            case '2': temp = 0xa4; break;
  39   3            case '3': temp = 0xb0; break;
  40   3      //    case '3': temp = 0x86; break;
  41   3            case '4': temp = 0x99; break;
  42   3      //    case '4': temp = 0x8b; break;
  43   3            case '5': temp = 0x92; break;
  44   3            case '6': temp = 0x82; break;
  45   3      //    case '6': temp = 0x90; break;
  46   3            case '7': temp = 0xf8; break;
  47   3      //    case '7': temp = 0xc7; break;
  48   3            case '8': temp = 0x80; break;
  49   3            case '9': temp = 0x90; break;
  50   3      //    case '9': temp = 0x82; break;
  51   3            case 'A': temp = 0x88; break;
  52   3            case 'B': temp = 0x83; break;
  53   3            case 'C': temp = 0xc6; break;
  54   3            case 'D': temp = 0xA1; break;
C51 COMPILER V9.56.0.0   SEG                                                               01/25/2025 07:47:21 PAGE 2   

  55   3            case 'E': temp = 0x86; break;
  56   3            case 'F': temp = 0x8E; break;
  57   3            case 'H': temp = 0x89; break;
  58   3            case 'L': temp = 0xC7; break;
  59   3            case 'N': temp = 0xC8; break;
  60   3            case 'P': temp = 0x8c; break;
  61   3            case 'U': temp = 0xC1; break;
  62   3            case '-': temp = 0xbf; break;
  63   3            case ' ': temp = 0xff; break;
  64   3            case '^': temp = 0xfe; break;         // 1 1 1 1 1 1 1 0
  65   3            case '_': temp = 0xf7; break;         // 1 1 1 1 0 1 1 1
  66   3            default: temp = 0xff;
  67   3          }
  68   2          if (pucSeg_Buf[j+1] == '.')
  69   2          {
  70   3            temp = temp&0x7f;               // 点亮小数点
  71   3            j++;
  72   3          }
  73   2          pucSeg_Code[i] = temp;
  74   2        }
  75   1      }
  76          // 数码管显示：ucSeg_Code-显示代码，ucSeg_Pos-显示位置
  77          void Seg_Disp(unsigned char ucSeg_Code, unsigned char ucSeg_Pos)
  78          {
  79   1        P0_Out(0xFF, 7);                    // 消隐
  80   1        P0_Out(1<<ucSeg_Pos, 6);            // 位选
  81   1        P0_Out(ucSeg_Code, 7);              // 段选
  82   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    367    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
