C51 COMPILER V9.52.0.0   TIM                                                               04/04/2024 07:18:06 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE TIM
OBJECT MODULE PLACED IN tim.OBJ
COMPILER INVOKED BY: C:\Keil_C51_v5\C51\BIN\C51.EXE tim.c LARGE BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "tim.h"
   2          
   3          extern volatile u32 ulMs;
   4          void Led_Disp(u8 ucOut)
   5          {
   6   1        P0=~ucOut;
   7   1        P2=(P2 & 0x1F) | 0x80;
   8   1        P2=P2 & 0x1F;
   9   1        //XBYTE[0x8000]=~ucOut;
  10   1      }
  11          
  12          void Cls_Waishe(void)
  13          {
  14   1        P0=0xFF;
  15   1        P2=(P2 & 0x1F) | 0x80;
  16   1        P2=P2 & 0x1F;
  17   1        //XBYTE[0x8000]=0xFF;
  18   1        P0=0x0;
  19   1        P2=(P2 & 0x1F) | 0xA0;
  20   1        P2=P2 & 0x1F;
  21   1        //XBYTE[0xA000]=0x00;
  22   1      }
  23          void Relay(u8 ucVal)
  24          {
  25   1        P0=0x0;
  26   1        if(ucVal)
  27   1          P0 |=1<<4;  
  28   1        else
  29   1          P0 &=~(1<<4);
  30   1        P2=(P2 & 0x1F) | 0xA0;
  31   1        P2=P2 & 0x1F;
  32   1        /*
  33   1        if(ucVal)
  34   1          XBYTE[0xA000]=1<<4; 
  35   1        else
  36   1          XBYTE[0xA000]=0x00;*/
  37   1      }
  38          void T1_Init(void)   //12T 12M
  39          {
  40   1        TH1=0xFC;
  41   1        TL1=0x18;
  42   1        TMOD &=0x0F;
  43   1        AUXR &=~(1<<6);
  44   1        TF1=0;
  45   1        ET1=1;
  46   1        EA=1;
  47   1        TR1=1;
  48   1      }
  49          void T0_Init(void)    //12T  @12.000MHz   ---P34 for Capture 
  50          {
  51   1        AUXR &= 0x7F;   //12T
  52   1        TMOD |= 0x04;   //mode 0
  53   1        TL0 = 0x00;   
  54   1        TH0 = 0x00;   
  55   1        TF0 = 0;    
C51 COMPILER V9.52.0.0   TIM                                                               04/04/2024 07:18:06 PAGE 2   

  56   1        TR0 = 1;    
  57   1        //ET0=1;
  58   1        //EA=1;
  59   1      }
  60          void Delay(u16 usIn)
  61          {
  62   1        u32 ulInit;
  63   1        ulInit=ulMs;
  64   1        while(ulMs-ulInit<usIn);  
  65   1      }
  66          void Seg_Tran(u8 *pBuff,u8 *pCode)
  67          {
  68   1        u8 i,j;
  69   1        for(i=0,j=0;j<8;i++,j++)
  70   1        {
  71   2          switch(*(pBuff+i))
  72   2          {
  73   3            case '0':
  74   3              *(pCode+j)=0xc0;
  75   3              break;
  76   3            case '1':
  77   3              *(pCode+j)=0xf9;
  78   3              break;
  79   3            case '2':
  80   3              *(pCode+j)=0xa4;
  81   3              break;
  82   3            case '3':
  83   3              *(pCode+j)=0xb0;
  84   3              break;
  85   3            case '4':
  86   3              *(pCode+j)=0x99;
  87   3              break;
  88   3            case '5':
  89   3              *(pCode+j)=0x92;
  90   3              break;
  91   3            case '6':
  92   3              *(pCode+j)=0x82;
  93   3              break;
  94   3            case '7':
  95   3              *(pCode+j)=0xf8;
  96   3              break;
  97   3            case '8':
  98   3              *(pCode+j)=0x80;
  99   3              break;
 100   3            case '9':
 101   3              *(pCode+j)=0x90;
 102   3              break;
 103   3            case 'A':
 104   3              *(pCode+j)=0x88;
 105   3              break;
 106   3            case 'B':
 107   3              *(pCode+j)=0x83;
 108   3              break;
 109   3            case 'C':
 110   3              *(pCode+j)=0xc6;
 111   3              break;
 112   3            case 'D':
 113   3              *(pCode+j)=0xa1;
 114   3              break;
 115   3            case 'E':
 116   3              *(pCode+j)=0x86;
 117   3              break;
C51 COMPILER V9.52.0.0   TIM                                                               04/04/2024 07:18:06 PAGE 3   

 118   3            case 'F':
 119   3              *(pCode+j)=0x8e;
 120   3              break;
 121   3            case '-':
 122   3              *(pCode+j)=0xbf;
 123   3              break;
 124   3            case ' ':
 125   3              *(pCode+j)=0xff;
 126   3              break;
 127   3            case '.':
 128   3              j=j-1;
 129   3              *(pCode+j) &=0x7f;
 130   3              break;
 131   3            case 'H':
 132   3              *(pCode+j)=0x89;
 133   3              break;
 134   3            case 'P':
 135   3              *(pCode+j)=0x8c;
 136   3              break;
 137   3            default:
 138   3              *(pCode+j)=0xff;        
 139   3          } 
 140   2        }
 141   1      }
 142          void Seg_Disp(u8 *pCode,u8 ucPos)
 143          {
 144   1        P0=0xFF;
 145   1        P2=(P2 & 0x1F)|0xe0;
 146   1        P2 =P2 & 0x1F;
 147   1        //XBYTE[0xE000]=0xFF;
 148   1        P0=(u8)1<<ucPos;
 149   1        P2=(P2 & 0x1F)|0xc0;
 150   1        P2 =P2 & 0x1F;
 151   1        //XBYTE[0xC000]=(u8)1<<ucPos;
 152   1        P0=*(pCode+ucPos);
 153   1        P2=(P2 & 0x1F)|0xe0;
 154   1        P2 =P2 & 0x1F;
 155   1        //XBYTE[0xE000]=*(pCode+ucPos);
 156   1      }
 157          u8 KBD_Read(void)
 158          {
 159   1        u16 uiArray1,uiArray2;
 160   1        u8 ucRtn=0;
 161   1        //P44=0;P42=1;P35=1;P34=1;     P34 used as Pwm out,in Capture
 162   1        P44=0;P42=1;
 163   1        uiArray1=P3 & 0x0F;
 164   1        P44=1;P42=0;
 165   1        uiArray1=(uiArray1 <<4) | P3 & 0x0F;    
 166   1        if(uiArray1==0x00FF) return 0;
 167   1        Delay(10);
 168   1        //P44=0;P42=1;P35=1;P34=1;
 169   1        P44=0;P42=1;
 170   1        uiArray2=P3 & 0x0F;
 171   1        P44=1;P42=0;
 172   1        uiArray2=(uiArray2 <<4) | P3 & 0x0F;
 173   1        
 174   1        if(uiArray1!=uiArray2) return 0;
 175   1        switch(~uiArray1)
 176   1        {
 177   2          case 0xFF80:
 178   2            ucRtn=1;
 179   2            break;
C51 COMPILER V9.52.0.0   TIM                                                               04/04/2024 07:18:06 PAGE 4   

 180   2          case 0xFF40:
 181   2            ucRtn=2;
 182   2            break;    
 183   2          case 0xFF20:
 184   2            ucRtn=3;
 185   2            break;    
 186   2          case 0xFF10:
 187   2            ucRtn=4;
 188   2            break;    
 189   2          case 0xFF08:
 190   2            ucRtn=5;
 191   2            break;
 192   2          case 0xFF04:
 193   2            ucRtn=6;
 194   2            break;    
 195   2          case 0xFF02:
 196   2            ucRtn=7;
 197   2            break;    
 198   2          case 0xFF01:
 199   2            ucRtn=8;
 200   2            break;    
 201   2          default:
 202   2            ucRtn=0;
 203   2        }
 204   1        return ucRtn;
 205   1      }
 206          u8 MaoPao_Filter(u8 *pucBuff,u8 ucLen)  
 207          {
 208   1        u8 i,j;
 209   1        u8 Temp;
 210   1        
 211   1        for(i=0;i<=ucLen-2;i++)    //ucLen/2
 212   1        {
 213   2          for(j=0;j<=ucLen-2-i ;j++)
 214   2          {
 215   3            if(pucBuff[j]>pucBuff[j+1])
 216   3            {
 217   4              Temp=pucBuff[j+1];
 218   4              pucBuff[j+1]=pucBuff[j];
 219   4              pucBuff[j]=Temp;
 220   4            }
 221   3          }
 222   2        }
 223   1        Temp=pucBuff[ucLen/2];
 224   1        return Temp;
 225   1      }
 226          u8 ComPare_Filter(u8 *pucBuff,u8 ucLen) 
 227          {
 228   1        u8 i,j,Temp;
 229   1        for(i=0;i<=ucLen-2;i++)
 230   1        {
 231   2          for(j=i+1;j<=ucLen-1;j++)
 232   2          {
 233   3            if(pucBuff[i]>pucBuff[j])
 234   3            {
 235   4              Temp=pucBuff[i];
 236   4              pucBuff[i]=pucBuff[j];
 237   4              pucBuff[j]=Temp;
 238   4            }
 239   3          }
 240   2        }
 241   1        Temp=pucBuff[ucLen/2];
C51 COMPILER V9.52.0.0   TIM                                                               04/04/2024 07:18:06 PAGE 5   

 242   1        return Temp;
 243   1      }
 244          
 245          void UartInit(void)   //9600bps@12.000MHz
 246          {
 247   1         SCON = 0x50; //????1
 248   1         AUXR |= 0x01;  //T2?????
 249   1         AUXR |= 0x04;      //1T
 250   1         T2L = 0xC7;  
 251   1         T2H = 0xFE;  
 252   1         AUXR |= 0x10;      //TR2
 253   1         ES=1;
 254   1         EA=1;
 255   1      }
 256          void UartSend(u8 *str1)
 257          {
 258   1        u8 i=0;
 259   1        while(str1[i])
 260   1        {
 261   2          SBUF=str1[i];
 262   2          i++;
 263   2          while(!TI);
 264   2          TI=0;
 265   2        }
 266   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1595    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      32
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
