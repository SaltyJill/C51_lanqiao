C51 COMPILER V9.52.0.0   TIM                                                               03/16/2024 12:40:38 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE TIM
OBJECT MODULE PLACED IN tim.OBJ
COMPILER INVOKED BY: C:\Keil_C51_v5\C51\BIN\C51.EXE tim.c LARGE BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "tim.h"
   2          
   3          extern volatile u32 uwMs;
   4          void Led_Disp(u8 ucOut)
   5          {
   6   1        P0=~ucOut;
   7   1        P2=(P2 & 0x1F) | 0x80;
   8   1        P2=P2 & 0x1F;
   9   1      }
  10          
  11          void Cls_Waishe(void)
  12          {
  13   1        P0=0xFF;
  14   1        P2=(P2 & 0x1F) | 0x80;
  15   1        P2=P2 & 0x1F;
  16   1        P0=0x0;
  17   1        P2=(P2 & 0x1F) | 0xA0;
  18   1        P2=P2 & 0x1F;
  19   1      }
  20          void Relay(u8 ucVal)
  21          {
  22   1        P0=0x0;
  23   1        if(ucVal)
  24   1          P0 |=1<<4;  //
  25   1        else
  26   1          P0 &=~(1<<4);
  27   1        P2=(P2 & 0x1F) | 0xA0;
  28   1        P2=P2 & 0x1F;
  29   1      }
  30          void T1_Init(void)   //12T 12M
  31          {
  32   1        TH1=0xFC;
  33   1        TL1=0x18;
  34   1        TMOD &=0x0F;
  35   1        AUXR &=~(1<<6);
  36   1        TF1=0;
  37   1        ET1=1;
  38   1        EA=1;
  39   1        TR1=1;
  40   1      }
  41          void T0_Init(void)    //12T  @12.000MHz   ---for Wave P10,P11
  42          {
  43   1        AUXR &= 0x7F;   //12T
  44   1        TMOD &= 0xF0;   
  45   1        TL0 = 0x00;   
  46   1        TH0 = 0x00;   
  47   1        //TF0 = 0;    
  48   1        TR0 = 0;    
  49   1      }
  50          void UartInit(void)   //9600bps@12.000MHz
  51          {
  52   1         SCON = 0x50; //????1
  53   1         AUXR |= 0x01;  //T2?????
  54   1         AUXR |= 0x04;      //1T
  55   1         T2L = 0xC7;  
C51 COMPILER V9.52.0.0   TIM                                                               03/16/2024 12:40:38 PAGE 2   

  56   1         T2H = 0xFE;  
  57   1         AUXR |= 0x10;      //TR2
  58   1         ES=1;
  59   1         EA=1;
  60   1      }
  61          void UartSend(u8 *str1)
  62          {
  63   1        u8 i=0;
  64   1        while(str1[i])
  65   1        {
  66   2          SBUF=str1[i];
  67   2          i++;
  68   2          while(!TI);
  69   2          TI=0;
  70   2        }
  71   1      }
  72          void Delay(u16 usIn)
  73          {
  74   1        u32 uwInit;
  75   1        uwInit=uwMs;
  76   1        while(uwMs-uwInit<usIn);  
  77   1      }
  78          void Seg_Tran(u8 *pBuff,u8 *pCode)
  79          {
  80   1        u8 i,j;
  81   1        for(i=0,j=0;j<8;i++,j++)
  82   1        {
  83   2          switch(*(pBuff+i))
  84   2          {
  85   3            case '0':
  86   3              *(pCode+j)=0xc0;
  87   3              break;
  88   3            case '1':
  89   3              *(pCode+j)=0xf9;
  90   3              break;
  91   3            case '2':
  92   3              *(pCode+j)=0xa4;
  93   3              break;
  94   3            case '3':
  95   3              *(pCode+j)=0xb0;
  96   3              break;
  97   3            case '4':
  98   3              *(pCode+j)=0x99;
  99   3              break;
 100   3            case '5':
 101   3              *(pCode+j)=0x92;
 102   3              break;
 103   3            case '6':
 104   3              *(pCode+j)=0x82;
 105   3              break;
 106   3            case '7':
 107   3              *(pCode+j)=0xf8;
 108   3              break;
 109   3            case '8':
 110   3              *(pCode+j)=0x80;
 111   3              break;
 112   3            case '9':
 113   3              *(pCode+j)=0x90;
 114   3              break;
 115   3            case 'A':
 116   3              *(pCode+j)=0x88;
 117   3              break;
C51 COMPILER V9.52.0.0   TIM                                                               03/16/2024 12:40:38 PAGE 3   

 118   3            case 'B':
 119   3              *(pCode+j)=0x83;
 120   3              break;
 121   3            case 'C':
 122   3              *(pCode+j)=0xc6;
 123   3              break;
 124   3            case 'D':
 125   3              *(pCode+j)=0xa1;
 126   3              break;
 127   3            case 'E':
 128   3              *(pCode+j)=0x86;
 129   3              break;
 130   3            case 'F':
 131   3              *(pCode+j)=0x8e;
 132   3              break;
 133   3            case 'U':   //0011 1110->1100 0001
 134   3              *(pCode+j)=0xc1;
 135   3              break;
 136   3            case '-':
 137   3              *(pCode+j)=0xbf;
 138   3              break;
 139   3            case ' ':
 140   3              *(pCode+j)=0xff;
 141   3              break;
 142   3            case '.':
 143   3              j=j-1;
 144   3              *(pCode+j) &=0x7f;
 145   3              break;
 146   3            default:
 147   3              *(pCode+j)=0xff;        
 148   3          } 
 149   2        }
 150   1      }
 151          void Seg_Disp(u8 *pCode,u8 ucPos)
 152          {
 153   1        P0=0xFF;
 154   1        P2=(P2 & 0x1F)|0xe0;
 155   1        P2 =P2 & 0x1F;
 156   1        P0=(u8)1<<ucPos;
 157   1        P2=(P2 & 0x1F)|0xc0;
 158   1        P2 =P2 & 0x1F;
 159   1        P0=*(pCode+ucPos);
 160   1        P2=(P2 & 0x1F)|0xe0;
 161   1        P2 =P2 & 0x1F;
 162   1      }
 163          u8 KBD_Read(void)
 164          {
 165   1        u16 uiArray1,uiArray2;
 166   1        u8 ucRtn=0;
 167   1        //P44=0;P42=1;P35=1;P34=1;     P34 used as Pwm out,in Capture
 168   1        P35=0;_nop_();P34=1;
 169   1        uiArray1=P3 & 0x0F;
 170   1        P35=1;P34=0;_nop_();
 171   1        uiArray1=(uiArray1 <<4) | P3 & 0x0F;    
 172   1        if(uiArray1==0x00FF) return 0;
 173   1        Delay(10);
 174   1        //P44=0;P42=1;P35=1;P34=1;
 175   1        P35=0;_nop_();P34=1;
 176   1        uiArray2=P3 & 0x0F;
 177   1        P35=1;P34=0;_nop_();
 178   1        uiArray2=(uiArray2 <<4) | P3 & 0x0F;
 179   1        
C51 COMPILER V9.52.0.0   TIM                                                               03/16/2024 12:40:38 PAGE 4   

 180   1        if(uiArray1!=uiArray2) return 0;
 181   1        switch(~uiArray1)
 182   1        {
 183   2          case 0xFF80:    //S12
 184   2            ucRtn=1;
 185   2            break;
 186   2          case 0xFF40:    //S13
 187   2            ucRtn=2;
 188   2            break;    
 189   2          case 0xFF20:
 190   2            ucRtn=3;
 191   2            break;    
 192   2          case 0xFF10:
 193   2            ucRtn=4;
 194   2            break;    
 195   2          case 0xFF08:    //S16
 196   2            ucRtn=5;
 197   2            break;
 198   2          case 0xFF04:    //S17
 199   2            ucRtn=6;
 200   2            break;    
 201   2          case 0xFF02:
 202   2            ucRtn=7;
 203   2            break;    
 204   2          case 0xFF01:
 205   2            ucRtn=8;
 206   2            break;    
 207   2          default:
 208   2            ucRtn=0;
 209   2        }
 210   1        return ucRtn;
 211   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1220    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      20
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
